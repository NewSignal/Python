# POJ2593
POJ2593上面有一段代码，在POJ2593中用到，算是POJ2593中的一部分，在这里一起讲。
看图“最大子段和_POJ1050.png”
生成a,b,m1,m2 4个变量。
a生成的随机数列，可以图中看到"7"被描上了。我们只用索引从1开始到结尾的数据。
b的大小是在a的有效大小前后各加上一位。为什么这么说，在处理b的过程中前后的0没有动，要不从索引1开始，要不从倒数第二个开始。
b虽然经过了前后两次循环，正向的循环生成的b对逆向循环没影响，相当于逆向循环的时候b重新清零，这里前后两个零就起到了隔离的效果。
b不管是从前往后循环还是从后往前，都秉持着如果是负数，就扔掉，不会对下一个数产生负影响。如果是正数就留着和下一个数相加，希望来产正的影响。
m1存放着b正向循环不减的数（因为有相等的数，不能说递增），如果b相比m1之前的值小了，就将m1之前的值给m1当前值，始终保持m1不减。
m2存放着b逆向循环，也就是b从右到左变化，m2也是从右到左变化，最后m2是从左到右不增的数。

# POJ1050
看图“最大子段和_POJ1050.png”。其中左边的图是生成的3×3的矩阵，右边的图每行每列累加前面所有列的和是3×4的矩阵。然后在执行寻找最大矩阵的操作，
从左上角开始寻找，画子矩阵的所有可能，从下往右，由小到大，穷举所有的可能情况。s_sum统计保留当前的正值，否则，s_max统计保留最大值。
