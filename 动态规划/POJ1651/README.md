#看图“动态规划_POJ1651.png”解释POJ1651的算法

我的代码设置数字N的值是10，图中的0到9表示10个数对应的下标。

前面的准备工作这里就不多说了。
首先要设置步长，看线1（就是图标1的那条红线），这条线上的数据是从10个数中随意抽取其中一个对应的情况（不包括首尾的数）。比如[0，2]表示抽取的数是索引1，
那么它的值应该为索引0*1*2。线1上的值在前面已经生成好了。接下来处理的是从10个数中连续抽出相邻的2个数的情况，也就是线2的情况。
循环i控制线中情况的个数，j控制从i到j之间的值被抽走，k是中间被抽走的数抽走的循序(抽走的循序不一样生成的数的结果不同，k的设立是为了找出结果数值最小的抽取循序)。
例[0,3]从中抽取了2个数，分别是索引1和索引2的数，我们先保留1，抽取2。相当于前一步抽取一个的情况，对应的值为[1,3],然后再抽取1，对应的值为索引0*1*3那么
总的值为两者相加，[0,1]+[1,3]+0*1*3,这里后面还加了个[0,1],也就是没有抽取数值为零，没有对结果造成影响。这里加[0,1]的意义是下一步就是保留2，抽取1，
这时[0,1]位置的值会被替换为[0,2],而[1,3]位置的值会被替换为 [2,3]（值为0）,也就是说为了生成一个通式，才加入的。
下面同理找步长为4，5，……9。这里将所有抽取的情况的最短路径都包括了。
这里有个情况就是抽取不连续的情况如何处理，没有思路。

