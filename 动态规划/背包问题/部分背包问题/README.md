# 部分背包问题
部分背包问题每件物品的个数是有限的。一个个处理起来太麻烦，我们将每件物品根据数量进行组合，比如说w[0]有7个，我们将7个分为1+2+4三组。
这样不论最优解中需要什么我们都可以进行相应的组合，需要3个w[0]我们给出1个w[0] 2个w[0]的组合。这样处理是为了减少计算量。
看图“部分背包问题.png”，我们一个个的从背包中抽取物品（每种的物品每次抽取的数量2^n）。
第一次抽取一个w[0],我们假设背包之前是满（这里的满和dp[j]的j相对应，j为满载的上限）。为了能放进去w[0],我们需要取出w[0]*数量的质量空间，放进去后
计算权值和不加入w[0]操作哪个权值大，保留谁，这里dp[5]=30，dp[4]=30,结束循环，能将取出的w[0]放进去就结束本次，下一步，取2w[0],for循环(5,7),不进入
循环，因为没有空间存放，后面同理，dp保持[0, 0, 0, 0, 30, 30]
加入1个w[1],dj[5]=max(dp[5],dp[5-3]+v[1])=max(30,31)=31，修改dp[5]=31。同理dp[4]=31,dp[3]=31。放入两个w[1],for(5,5)没有质量给2个w[1]，结束。
dp=[0, 0, 0, 31, 31, 31]。
放入1个w[2]，dp[5]=max(31,8)=31，保持不变，和上面同理，dp=[0, 0, 0, 31, 31, 31]
放入1个w[3],dp[5]=max(31,31+19)=50也就是说能放入1个w[0]和1个w[3]。继续循环，dp[4]=max(dp[4],dp[2]+v[3]*1)=max(31,19)=31,
dp[3]=max(dp[3],dp[1]+v[3]*1)=max(31,19)=31,dp[2]=max(dp[2],dp[0]+v[3]*1)=max(0,19)=19,dp=[0, 0, 19, 31, 38, 50]
放入2个w[3],for（5，3）进入循环，dp[5]=max(dp[5],dp[5-4]+v[3]*2)=max(50,38)=50,dp[4]=max(dp[4],dp[0]+v[3]*2)=max(38,38)=38
放入4个w[3],for(5,7),不进入循环，
8=1+2+4+1，最后还有一次放入1个w[3]的情况，dp=[0, 0, 19, 31, 38, 50]
最后放入1个w[4],dp[5]=max(dp[5],dp[1]+v[4])=max(50,42)=50,dp[4]=max(dp[4],dp[0]+v[4])=max(38,42)=42,dp=[0, 0, 19, 31, 42, 50]
数量2=1+1还有一次，其实可以优化代码取消因为和上次循环一样。
